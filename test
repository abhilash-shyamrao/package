CREATE OR REPLACE FUNCTION log_unified_view_changes()
RETURNS TRIGGER AS $$
DECLARE
    transaction_id UUID := gen_random_uuid();  -- Generate a unique transaction ID
    pk_column TEXT;  -- Variable to store the primary key column name
    row_id TEXT;  -- Variable to store the row's unique identifier
BEGIN
    -- Retrieve the primary key column name dynamically from information_schema
    SELECT c.column_name
    INTO pk_column
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.columns c
        ON c.table_name = kcu.table_name
        AND c.column_name = kcu.column_name
    WHERE tc.constraint_type = 'PRIMARY KEY'
    AND tc.table_name = TG_TABLE_NAME
    LIMIT 1;

    -- For UPDATE or DELETE operations, use OLD for row_id
    IF TG_OP IN ('UPDATE', 'DELETE') THEN
        -- Access the primary key column directly using OLD
        row_id := OLD.pk_column::TEXT;  -- Replace `pk_column` with the actual primary key column name
    END IF;

    -- For INSERT operation, use NEW for row_id
    IF TG_OP = 'INSERT' THEN
        -- Access the primary key column directly using NEW
        row_id := NEW.pk_column::TEXT;  -- Replace `pk_column` with the actual primary key column name
    END IF;

    IF TG_OP = 'UPDATE' THEN
        -- Log each column where values changed
        INSERT INTO dqc_schema.audit_log (transaction_id, table_name, row_identifier, column_name, old_value, new_value, changed_on, changed_by)
        SELECT
            transaction_id,
            TG_TABLE_NAME,
            row_id,  -- Use the unique row identifier
            col.column_name,  -- Column name that changed
            to_jsonb(OLD.*)::jsonb -> col.column_name, -- Old value
            to_jsonb(NEW.*)::jsonb -> col.column_name, -- New value
            NOW(),
            CURRENT_USER
        FROM (
            SELECT unnest(array(SELECT column_name FROM information_schema.columns 
                                WHERE table_name = TG_TABLE_NAME)) AS column_name
        ) AS col
        WHERE to_jsonb(OLD.*)::jsonb -> col.column_name IS DISTINCT FROM to_jsonb(NEW.*)::jsonb -> col.column_name;

    ELSIF TG_OP = 'DELETE' THEN
        -- Log the deleted row
        INSERT INTO dqc_schema.audit_log (transaction_id, table_name, row_identifier, column_name, old_value, new_value, changed_on, changed_by)
        VALUES (
            transaction_id,
            TG_TABLE_NAME,
            row_id,  -- Use the unique row identifier
            NULL,
            row_to_json(OLD)::jsonb, -- Store the entire deleted row
            NULL,
            NOW(),
            CURRENT_USER
        );

    ELSIF TG_OP = 'INSERT' THEN
        -- Log the inserted row
        INSERT INTO dqc_schema.audit_log (transaction_id, table_name, row_identifier, column_name, old_value, new_value, changed_on, changed_by)
        VALUES (
            transaction_id,
            TG_TABLE_NAME,
            row_id,  -- Use the unique row identifier
            NULL,
            NULL,
            row_to_json(NEW)::jsonb, -- Store the entire inserted row
            NOW(),
            CURRENT_USER
        );
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
